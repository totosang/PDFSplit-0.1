<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡πÅ‡∏¢‡∏Å‡πÑ‡∏ü‡∏•‡πå PDFSplit - Smooth & Fit</title>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    </script>

    <style>
        :root { 
            --base-height: 250px; /* ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡πÅ‡∏ó‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö‡∏á‡πà‡∏≤‡∏¢ */
        }
        
        body { font-family: 'Sarabun', sans-serif; background-color: #f4f4f9; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        h1 { color: #333; margin-bottom: 10px; }

        /* Drop Zone */
        #drop-zone {
            width: 80%; max-width: 600px; height: 120px;
            border: 2px dashed #007bff; border-radius: 10px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background-color: #fff; color: #007bff; font-size: 1.1rem; cursor: pointer;
            transition: background 0.3s; margin-bottom: 20px;
        }
        #drop-zone.dragover { background-color: #e6f2ff; border-color: #0056b3; }
        .small-text { font-size: 0.85rem; color: #666; margin-top: 5px; }

        /* Toolbar */
        .toolbar {
            display: flex; gap: 15px; align-items: center; margin-bottom: 20px;
            background: white; padding: 10px 20px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            flex-wrap: wrap; justify-content: center;
        }
        input[type="range"] { cursor: pointer; width: 150px; }
        
        button { border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 0.9rem; transition: 0.2s; }
        #reset-btn { background-color: #dc3545; color: white; }
        #reset-btn:hover { background-color: #c82333; }
        .selection-btn { background-color: #6c757d; color: white; }
        .selection-btn:hover { background-color: #5a6268; }

        /* Page List Container */
        #page-list {
            width: 98%; max-width: 1600px; 
            display: flex; 
            flex-wrap: wrap; 
            gap: 20px;
            justify-content: center; 
            align-items: flex-start; /* ‡∏à‡∏±‡∏î‡πÉ‡∏´‡πâ‡∏ä‡∏¥‡∏î‡∏ö‡∏ô */
            padding: 10px; min-height: 200px;
        }

        /* Page Card Style */
        .page-card {
            background: white; 
            border: 1px solid #ddd; 
            border-radius: 8px; 
            padding: 10px;
            /* ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: ‡πÉ‡∏´‡πâ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏¢‡∏∑‡∏î‡∏´‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏†‡∏≤‡∏¢‡πÉ‡∏ô (Canvas) */
            width: fit-content; 
            display: flex; flex-direction: column; align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
            position: relative; 
            cursor: grab;
            /* Smooth Transition */
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.1s;
        }

        /* ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å: ‡∏Å‡∏£‡∏≠‡∏ö‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡πÅ‡∏ô‡∏ö‡πÄ‡∏ô‡∏∑‡πâ‡∏≠ */
        .page-card.selected { 
            border: 3px solid #28a745; 
            background-color: #f0fff4; 
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.2);
        }

        /* ‡∏Ç‡∏ì‡∏∞‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏•‡∏≤‡∏Å (‡∏ï‡∏±‡∏ß‡∏ï‡πâ‡∏ô‡∏ó‡∏≤‡∏á) */
        .page-card.dragging { 
            opacity: 0.4; 
            border: 2px dashed #007bff; 
            transform: scale(0.95);
        }

        /* Canvas Container */
        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 5px;
            overflow: hidden;
            border-radius: 4px;
        }
        
        .page-card canvas { 
            /* ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏ï‡∏≤‡∏° Slider ‡∏™‡πà‡∏ß‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏à‡∏∞ Auto ‡∏ï‡∏≤‡∏° Ratio */
            height: var(--base-height);
            width: auto;
            border: 1px solid #eee; 
            pointer-events: none; 
            display: block;
        }

        /* Elements on Card */
        .page-number-label {
            position: absolute; top: -12px; left: 50%; transform: translateX(-50%);
            background-color: #333; color: white; padding: 2px 10px; border-radius: 10px;
            font-size: 0.8rem; z-index: 25; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .rotate-btn {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 45px; height: 45px; background-color: rgba(0, 0, 0, 0.6); color: white;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            cursor: pointer; font-size: 1.4rem; z-index: 20; opacity: 0; transition: opacity 0.2s, transform 0.2s;
        }
        .page-card:hover .rotate-btn { opacity: 1; }
        .rotate-btn:hover { background-color: rgba(0, 123, 255, 0.9); transform: translate(-50%, -50%) scale(1.1); }

        .page-info { 
            font-size: 0.75rem; color: #555; 
            max-width: 200px; /* ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏¢‡∏≤‡∏ß‡πÄ‡∏Å‡∏¥‡∏ô */
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 
            text-align: center; margin-top: 5px; 
        }
        
        .page-checkbox { position: absolute; top: 8px; left: 8px; width: 22px; height: 22px; cursor: pointer; z-index: 20; accent-color: #28a745; }
        
        .delete-btn {
            position: absolute; top: -10px; right: -10px; width: 28px; height: 28px;
            background-color: #ff4d4d; color: white; border: 2px solid white; border-radius: 50%;
            display: flex; align-items: center; justify-content: center; cursor: pointer; font-weight: bold; font-size: 16px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2); z-index: 30; transition: transform 0.1s;
        }
        .delete-btn:hover { background-color: #ff0000; transform: scale(1.1); }

        /* Action Buttons */
        .action-buttons {
            display: none; position: sticky; bottom: 20px; z-index: 100;
            gap: 15px; margin-top: 20px; background: rgba(255, 255, 255, 0.9);
            padding: 15px; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            backdrop-filter: blur(5px);
        }
        .btn-action {
            padding: 12px 25px; font-size: 1.1rem; color: white; border-radius: 50px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2); display: flex; align-items: center; gap: 8px;
        }
        .btn-merge { background-color: #28a745; }
        .btn-merge:hover { background-color: #218838; transform: translateY(-2px); }
        .btn-zip { background-color: #007bff; }
        .btn-zip:hover { background-color: #0056b3; transform: translateY(-2px); }
        .btn-jpg { background-color: #ffc107; color: #333; }
        .btn-jpg:hover { background-color: #e0a800; transform: translateY(-2px); }
        button:disabled { background-color: #ccc; cursor: not-allowed; transform: none; box-shadow: none; color: #666; }

    </style>
</head>
<body>

    <h1>‡πÅ‡∏¢‡∏Å‡πÑ‡∏ü‡∏•‡πå PDFSplit - Smooth & Fit</h1>
    
    <div class="toolbar">
        <div style="display:flex; align-items:center; gap:10px;">
            <label>‡∏Ç‡∏ô‡∏≤‡∏î‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•:</label>
            <input type="range" id="zoom-slider" min="150" max="500" value="250">
        </div>
        <button class="selection-btn" onclick="toggleSelectAll(true)">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
        <button class="selection-btn" onclick="toggleSelectAll(false)">‡πÑ‡∏°‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏•‡∏¢</button>
        <button id="reset-btn" onclick="resetAll()">‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡∏°‡πà (Reset)</button>
    </div>

    <div id="drop-zone">
        <span>‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå PDF ‡∏°‡∏≤‡∏ß‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà (‡∏´‡∏•‡∏≤‡∏¢‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ)</span>
        <span class="small-text">‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÅ‡∏¢‡∏Å‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏•‡∏∑‡∏≠‡∏Å</span>
    </div>
    
    <input type="file" id="file-input" multiple accept="application/pdf" style="display: none;">

    <div id="page-list"></div>

    <div class="action-buttons" id="action-area">
        <button class="btn-action btn-merge" onclick="processFiles('merge')">
            üìë ‡∏£‡∏ß‡∏°‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏î‡∏µ‡∏¢‡∏ß (.pdf)
        </button>
        <button class="btn-action btn-zip" onclick="processFiles('zip')">
            üì¶ ‡πÅ‡∏¢‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏¢‡πà‡∏≠‡∏¢ (.zip)
        </button>
        <button class="btn-action btn-jpg" onclick="processFiles('jpg')">
            üñºÔ∏è ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û (.jpg)
        </button>
    </div>

    <script>
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const pageListContainer = document.getElementById('page-list');
        const actionArea = document.getElementById('action-area');
        const zoomSlider = document.getElementById('zoom-slider');
        
        let pagesMap = new Map(); 
        let sourcesMap = new Map();
        let currentBaseHeight = 250; 

        // --- 1. Zoom Logic ---
        zoomSlider.addEventListener('input', (e) => {
            currentBaseHeight = parseInt(e.target.value);
            // ‡∏õ‡∏£‡∏±‡∏ö CSS Variable ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏∏‡∏Å‡πÉ‡∏ö‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ç‡∏ô‡∏≤‡∏î‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
            document.documentElement.style.setProperty('--base-height', currentBaseHeight + 'px');
        });
        
        // Re-render ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏°‡∏ä‡∏±‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏•‡πà‡∏≠‡∏¢‡πÄ‡∏°‡∏≤‡∏™‡πå
        zoomSlider.addEventListener('change', () => {
            reRenderAllVisiblePages();
        });

        async function reRenderAllVisiblePages() {
            const cards = document.querySelectorAll('.page-card');
            for (const card of cards) {
                const pageData = pagesMap.get(card.id);
                if (pageData) await renderPageThumbnail(card.id, pageData);
            }
        }

        // --- Drag & Drop Handling ---
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault(); dropZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

        // --- 2. Smooth Sorting Logic with Ghost Image ---
        pageListContainer.addEventListener('dragover', (e) => {
            e.preventDefault(); // ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ Drop
            const afterElement = getDragAfterElement(pageListContainer, e.clientX, e.clientY);
            const draggable = document.querySelector('.dragging');
            if (draggable) {
                if (afterElement == null) {
                    pageListContainer.appendChild(draggable);
                } else {
                    pageListContainer.insertBefore(draggable, afterElement);
                }
            }
        });

        function getDragAfterElement(container, x, y) {
            // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏•‡∏≤‡∏Å
            const draggableElements = [...container.querySelectorAll('.page-card:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                
                // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡πà‡∏≠‡∏á
                const boxCenterX = box.left + box.width / 2;
                const boxCenterY = box.top + box.height / 2;

                // ‡∏´‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á (Distance) ‡πÅ‡∏ö‡∏ö Euclidean ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥
                const dist = Math.hypot(x - boxCenterX, y - boxCenterY);

                if (dist < closest.dist) {
                    return { dist: dist, element: child };
                } else {
                    return closest;
                }
            }, { dist: Number.POSITIVE_INFINITY }).element;
        }

        // --- 3. File Handling ---
        async function handleFiles(files) {
            for (const file of files) {
                if (file.type !== 'application/pdf') { alert('‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà PDF: ' + file.name); continue; }
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const sourceId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                    sourcesMap.set(sourceId, { buffer: arrayBuffer, name: file.name.replace('.pdf', '') });

                    const loadingTask = pdfjsLib.getDocument(arrayBuffer);
                    const pdf = await loadingTask.promise;

                    for (let i = 1; i <= pdf.numPages; i++) {
                        await createPageCard(pdf, i, sourceId, file.name);
                    }
                } catch (err) { console.error(err); alert("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå " + file.name + " ‡πÑ‡∏î‡πâ"); }
            }
            updateUI();
        }

        async function createPageCard(pdf, pageNumber, sourceId, fileName) {
            const cardId = 'card-' + Math.random().toString(36).substr(2, 9);
            
            const card = document.createElement('div');
            card.className = 'page-card selected'; 
            card.id = cardId; 
            card.draggable = true;

            const pageNumLabel = document.createElement('div');
            pageNumLabel.className = 'page-number-label';
            pageNumLabel.textContent = `‡∏´‡∏ô‡πâ‡∏≤ ${pageNumber}`;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox'; checkbox.className = 'page-checkbox'; checkbox.checked = true;
            checkbox.onchange = (e) => { e.target.checked ? card.classList.add('selected') : card.classList.remove('selected'); };

            const rotateBtn = document.createElement('div');
            rotateBtn.className = 'rotate-btn';
            rotateBtn.innerHTML = '‚Üª';
            rotateBtn.title = "‡∏´‡∏°‡∏∏‡∏ô‡∏†‡∏≤‡∏û 90 ‡∏≠‡∏á‡∏®‡∏≤";
            rotateBtn.onclick = (e) => {
                e.stopPropagation();
                rotatePage(cardId);
            };

            const canvasContainer = document.createElement('div');
            canvasContainer.className = 'canvas-container';
            canvasContainer.id = 'container-' + cardId;
            
            const canvas = document.createElement('canvas');
            canvas.id = 'canvas-' + cardId;
            canvasContainer.appendChild(canvas);

            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn'; deleteBtn.innerHTML = '&times;';
            deleteBtn.onclick = () => { pagesMap.delete(cardId); card.remove(); updateUI(); };

            const info = document.createElement('div');
            info.className = 'page-info'; info.textContent = fileName;

            // --- Custom Ghost Image Logic ---
            card.addEventListener('dragstart', (e) => {
                card.classList.add('dragging');
                
                // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û‡πÄ‡∏á‡∏≤ (Ghost Image) ‡∏ó‡∏µ‡πà‡∏à‡∏≤‡∏á‡πÜ
                const ghost = card.cloneNode(true);
                ghost.style.position = "absolute"; 
                ghost.style.top = "-1000px"; // ‡∏ã‡πà‡∏≠‡∏ô‡πÑ‡∏ß‡πâ‡∏ô‡∏≠‡∏Å‡∏à‡∏≠
                ghost.style.opacity = "0.5";
                ghost.style.transform = "scale(0.8)"; // ‡∏¢‡πà‡∏≠‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÉ‡∏´‡πâ‡∏î‡∏π‡∏™‡∏ß‡∏¢
                document.body.appendChild(ghost);
                
                // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Drag Image
                e.dataTransfer.setDragImage(ghost, e.offsetX, e.offsetY);
                
                // ‡∏•‡∏ö DOM ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡∏≠‡∏≠‡∏Å‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏•‡∏≤‡∏Å
                setTimeout(() => document.body.removeChild(ghost), 0);
            });

            card.addEventListener('dragend', () => card.classList.remove('dragging'));

            card.append(pageNumLabel, checkbox, rotateBtn, deleteBtn, canvasContainer, info);
            pageListContainer.appendChild(card);

            // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
            pagesMap.set(cardId, { sourceId: sourceId, pageIndex: pageNumber - 1, rotation: 0 });

            // Render ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å
            await renderPageThumbnail(cardId, pagesMap.get(cardId));
        }

        // --- Render Thumbnail with Auto-Fit ---
        async function renderPageThumbnail(cardId, pageData) {
            const sourceInfo = sourcesMap.get(pageData.sourceId);
            if (!sourceInfo) return;

            const loadingTask = pdfjsLib.getDocument(sourceInfo.buffer.slice(0));
            const pdf = await loadingTask.promise;
            const page = await pdf.getPage(pageData.pageIndex + 1);

            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Scale
            // ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏Å‡∏ì‡∏ë‡πå (Height-based) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏ñ‡∏ß‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ô
            const viewportBasic = page.getViewport({ scale: 1.0 });
            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏ï‡πâ‡∏≠‡∏á Zoom ‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÑ‡∏î‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏ï‡∏≤‡∏° Slider (currentBaseHeight)
            // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏´‡∏°‡∏∏‡∏ô‡πÑ‡∏´‡∏°? ‡∏ñ‡πâ‡∏≤‡∏´‡∏°‡∏∏‡∏ô 90/270 ‡∏™‡∏•‡∏±‡∏ö W/H
            const isRotated = pageData.rotation % 180 !== 0;
            
            // ‡∏´‡∏≤ Scale ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏Å‡∏±‡∏ö‡∏à‡∏≠ (Device Pixel Ratio) + Slider
            const targetHeight = currentBaseHeight; 
            const scale = (targetHeight / (isRotated ? viewportBasic.width : viewportBasic.height)) * (window.devicePixelRatio || 1);
            
            // Viewport ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô (pdf.js ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏•‡∏±‡∏ö W/H ‡πÉ‡∏´‡πâ‡πÄ‡∏≠‡∏á)
            const totalRotation = (page.rotate + pageData.rotation) % 360;
            const viewport = page.getViewport({ scale: scale, rotation: totalRotation });

            const canvas = document.getElementById('canvas-' + cardId);
            const context = canvas.getContext('2d');
            
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            
            // ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á CSS ‡πÉ‡∏´‡πâ‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö Slider (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏™‡∏π‡∏á‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ô‡πÉ‡∏ô‡πÅ‡∏ñ‡∏ß)
            canvas.style.height = currentBaseHeight + "px";
            canvas.style.width = "auto"; // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏õ‡∏•‡πà‡∏≠‡∏¢‡∏ü‡∏£‡∏µ‡∏ï‡∏≤‡∏°‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô

            await page.render({ canvasContext: context, viewport: viewport }).promise;
        }

        // --- Rotation Logic ---
        async function rotatePage(cardId) {
            const pageData = pagesMap.get(cardId);
            if (!pageData) return;

            // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ó‡∏µ‡∏•‡∏∞ 90 ‡∏≠‡∏á‡∏®‡∏≤
            pageData.rotation = (pageData.rotation + 90) % 360;
            pagesMap.set(cardId, pageData);

            // Re-render ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏π‡∏õ‡∏ó‡∏£‡∏á‡∏Å‡∏≤‡∏£‡πå‡∏î
            await renderPageThumbnail(cardId, pageData);
        }

        // --- 4. Process Files (Download Logic) ---
        async function processFiles(mode) {
            const cards = document.querySelectorAll('.page-card');
            const selectedCards = Array.from(cards).filter(card => card.querySelector('.page-checkbox').checked);

            if (selectedCards.length === 0) return alert("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡∏´‡∏ô‡πâ‡∏≤");

            setLoading(true);

            try {
                const { PDFDocument, degrees } = PDFLib;
                const loadedDocsCache = new Map();

                if (mode === 'merge' || mode === 'zip') {
                    const outputZip = (mode === 'zip') ? new JSZip() : null;
                    const mergedPdf = (mode === 'merge') ? await PDFDocument.create() : null;
                    let count = 1;

                    for (const card of selectedCards) {
                        const pageData = pagesMap.get(card.id);
                        let sourcePdfDoc = await getSourcePdf(pageData.sourceId, loadedDocsCache, PDFDocument);
                        
                        // Copy ‡∏´‡∏ô‡πâ‡∏≤
                        const [copiedPage] = await (mode === 'merge' ? mergedPdf : await PDFDocument.create()).copyPages(sourcePdfDoc, [pageData.pageIndex]);
                        
                        // *** Apply Rotation Only (No Scale Change) ***
                        // ‡πÄ‡∏≠‡∏≤‡∏≠‡∏á‡∏®‡∏≤‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå + ‡∏≠‡∏á‡∏®‡∏≤‡∏ó‡∏µ‡πà user ‡∏´‡∏°‡∏∏‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°
                        const existingRotation = copiedPage.getRotation().angle;
                        copiedPage.setRotation(degrees(existingRotation + pageData.rotation));

                        if (mode === 'merge') {
                            mergedPdf.addPage(copiedPage);
                        } else {
                            const singleDoc = await PDFDocument.create();
                            // ‡∏ï‡πâ‡∏≠‡∏á Clone ‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏¢‡∏Å
                            const [singlePage] = await singleDoc.copyPages(sourcePdfDoc, [pageData.pageIndex]);
                            const currentRot = singlePage.getRotation().angle;
                            singlePage.setRotation(degrees(currentRot + pageData.rotation));
                            
                            singleDoc.addPage(singlePage);
                            const pdfBytes = await singleDoc.save();
                            const originalName = sourcesMap.get(pageData.sourceId).name;
                            const fileName = `${count.toString().padStart(3, '0')}_${originalName}_Page${pageData.pageIndex + 1}.pdf`;
                            outputZip.file(fileName, pdfBytes);
                            count++;
                        }
                    }

                    if (mode === 'merge') {
                        const pdfBytes = await mergedPdf.save();
                        download(pdfBytes, "Merged_Document.pdf", "application/pdf");
                    } else {
                        const zipContent = await outputZip.generateAsync({ type: "blob" });
                        download(zipContent, "Split_PDFs.zip", "application/zip");
                    }

                } else if (mode === 'jpg') {
                    const zip = new JSZip();
                    let count = 1;

                    for (const card of selectedCards) {
                        const pageData = pagesMap.get(card.id);
                        const sourceInfo = sourcesMap.get(pageData.sourceId);
                        
                        // ‡πÇ‡∏´‡∏•‡∏î‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠ Render JPG ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á (Scale 3.0)
                        const loadingTask = pdfjsLib.getDocument(sourceInfo.buffer.slice(0));
                        const pdf = await loadingTask.promise;
                        const page = await pdf.getPage(pageData.pageIndex + 1);

                        // ‡∏´‡∏°‡∏∏‡∏ô‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà User ‡∏™‡∏±‡πà‡∏á
                        const totalRotation = (page.rotate + pageData.rotation) % 360;
                        const viewport = page.getViewport({ scale: 3.0, rotation: totalRotation }); 

                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height; 
                        canvas.width = viewport.width;

                        await page.render({ canvasContext: context, viewport: viewport }).promise;

                        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.95));
                        const originalName = sourceInfo.name;
                        const fileName = `${count.toString().padStart(3, '0')}_${originalName}_Page${pageData.pageIndex + 1}.jpg`;
                        
                        if (selectedCards.length === 1) {
                            download(blob, fileName, "image/jpeg");
                            setLoading(false);
                            return; 
                        } else {
                            zip.file(fileName, blob);
                        }
                        count++;
                    }

                    if (selectedCards.length > 1) {
                        const zipContent = await zip.generateAsync({ type: "blob" });
                        download(zipContent, "Images_Package.zip", "application/zip");
                    }
                }

            } catch (err) {
                console.error(err);
                alert("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: " + err.message);
            } finally {
                setLoading(false);
            }
        }

        async function getSourcePdf(sourceId, cache, PDFLibDoc) {
            if (!cache.has(sourceId)) {
                const buffer = sourcesMap.get(sourceId).buffer;
                const pdfDoc = await PDFLibDoc.load(buffer);
                cache.set(sourceId, pdfDoc);
            }
            return cache.get(sourceId);
        }

        function toggleSelectAll(select) {
            document.querySelectorAll('.page-card').forEach(card => {
                const cb = card.querySelector('.page-checkbox');
                cb.checked = select;
                select ? card.classList.add('selected') : card.classList.remove('selected');
            });
        }

        function resetAll() {
            if (pagesMap.size > 0 && !confirm("‡∏•‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î?")) return;
            pagesMap.clear(); sourcesMap.clear();
            pageListContainer.innerHTML = ''; fileInput.value = '';
            updateUI();
        }

        function updateUI() {
            actionArea.style.display = pagesMap.size > 0 ? 'flex' : 'none';
        }

        function setLoading(isLoading) {
            const btns = document.querySelectorAll('.btn-action');
            btns.forEach(btn => btn.disabled = isLoading);
            if (isLoading) document.body.style.cursor = 'wait';
            else document.body.style.cursor = 'default';
        }

        function download(data, filename, type) {
            const blob = data instanceof Blob ? data : new Blob([data], { type: type });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }
    </script>
</body>
</html>
